%{
#include<stdio.h>
#include<stdlib.h>
#include<string.h>

typedef struct node{
    int flag;
    int ival;
    char op;
    struct node* left;
    struct node* right;
    struct node * parent;
}tnode;
tnode* mknode(char* str, tnode* left_p, tnode* right_p);
tnode* mkleaf(int a);
int isleaf(tnode* a);
int prefix(tnode* a);
int infix(tnode* a);
int postfix(tnode* a);

void yyerror(char *msg);
char* concat(char* a,char*b);
char* dyna_copy(char* a);
extern int yylex();
%}
%union {
    tnode* t;
    int ival;       
}
%token <ival> NUM
%type <t> E
%left '+'
%left '*'
%%
S : E   {tree_eval($1)};

E : E '+' E {$$=mknode("+",$1,$3);}
  | E '*' E  {$$=mknode("*",$1,$3);} 
  | '(' E ')' {$$= $2;}
  | NUM    {$$=mkleaf($1);}
  ;

%%

void yyerror(char *msg){
    fprintf(stderr,"%s\n",msg);
    exit(1);
}
char* concat(char* a,char* b){
    int y,x;
    char* i;
    x=strlen(a)+strlen(b)+1;
    i=(char*)malloc((strlen(a)+strlen(b)+1)*sizeof(char)); 
    y=0;
    for(y=0;y<x-1;y++){
        if(y<strlen(a)){
            i[y]=a[y];
        }
        else{
            i[y]=b[y-strlen(a)];
        }
    }
    printf("a   %s   %d\n",a,strlen(a));
    printf("b   %s   %d\n",b,strlen(b));
    printf("%s\n",i);
    i[y]='\0';
    return i;
}
char* dyna_copy(char* a){
    int l,y;
    char* i;
    l=strlen(a);
    i=(char*)malloc((l+1)*sizeof(char));
    for(y=0;y<l;y++){
        i[y]=a[y];
        
    }
    i[y]='\0';
    return i;
}
int main(){
    yyparse();
    return 0;   
}
